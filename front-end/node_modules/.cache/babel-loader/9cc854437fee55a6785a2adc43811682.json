{"ast":null,"code":"import _extends from \"@babel/runtime/helpers/extends\";\nimport _objectWithoutPropertiesLoose from \"@babel/runtime/helpers/objectWithoutPropertiesLoose\";\nimport React from 'react';\nimport PropTypes from 'prop-types';\nimport warning from 'warning';\nimport classNames from 'classnames';\nimport { componentPropType } from '@material-ui/utils';\nimport RootRef from '../RootRef';\nimport withStyles from '../styles/withStyles';\nimport { capitalize } from '../utils/helpers';\nimport Grow from '../Grow';\nimport Popper from '../Popper';\nexport const styles = theme => ({\n  /* Styles applied to the Popper component. */\n  popper: {\n    zIndex: theme.zIndex.tooltip,\n    opacity: 0.9,\n    pointerEvents: 'none'\n  },\n\n  /* Styles applied to the Popper component if `interactive={true}`. */\n  popperInteractive: {\n    pointerEvents: 'auto'\n  },\n\n  /* Styles applied to the tooltip (label wrapper) element. */\n  tooltip: {\n    backgroundColor: theme.palette.grey[700],\n    borderRadius: theme.shape.borderRadius,\n    color: theme.palette.common.white,\n    fontFamily: theme.typography.fontFamily,\n    padding: '4px 8px',\n    fontSize: theme.typography.pxToRem(10),\n    lineHeight: \"\".concat(theme.typography.round(14 / 10), \"em\"),\n    maxWidth: 300\n  },\n\n  /* Styles applied to the tooltip (label wrapper) element if the tooltip is opened by touch. */\n  touch: {\n    padding: '8px 16px',\n    fontSize: theme.typography.pxToRem(14),\n    lineHeight: \"\".concat(theme.typography.round(16 / 14), \"em\")\n  },\n\n  /* Styles applied to the tooltip (label wrapper) element if `placement` contains \"left\". */\n  tooltipPlacementLeft: {\n    transformOrigin: 'right center',\n    margin: '0 24px ',\n    [theme.breakpoints.up('sm')]: {\n      margin: '0 14px'\n    }\n  },\n\n  /* Styles applied to the tooltip (label wrapper) element if `placement` contains \"right\". */\n  tooltipPlacementRight: {\n    transformOrigin: 'left center',\n    margin: '0 24px',\n    [theme.breakpoints.up('sm')]: {\n      margin: '0 14px'\n    }\n  },\n\n  /* Styles applied to the tooltip (label wrapper) element if `placement` contains \"top\". */\n  tooltipPlacementTop: {\n    transformOrigin: 'center bottom',\n    margin: '24px 0',\n    [theme.breakpoints.up('sm')]: {\n      margin: '14px 0'\n    }\n  },\n\n  /* Styles applied to the tooltip (label wrapper) element if `placement` contains \"bottom\". */\n  tooltipPlacementBottom: {\n    transformOrigin: 'center top',\n    margin: '24px 0',\n    [theme.breakpoints.up('sm')]: {\n      margin: '14px 0'\n    }\n  }\n});\n\nclass Tooltip extends React.Component {\n  constructor(props) {\n    super();\n    this.ignoreNonTouchEvents = false;\n\n    this.onRootRef = ref => {\n      this.childrenRef = ref;\n    };\n\n    this.handleFocus = event => {\n      // Workaround for https://github.com/facebook/react/issues/7769\n      // The autoFocus of React might trigger the event before the componentDidMount.\n      // We need to account for this eventuality.\n      if (!this.childrenRef) {\n        this.childrenRef = event.currentTarget;\n      }\n\n      this.handleEnter(event);\n      const childrenProps = this.props.children.props;\n\n      if (childrenProps.onFocus) {\n        childrenProps.onFocus(event);\n      }\n    };\n\n    this.handleEnter = event => {\n      const _this$props2 = this.props,\n            children = _this$props2.children,\n            enterDelay = _this$props2.enterDelay;\n      const childrenProps = children.props;\n\n      if (event.type === 'mouseover' && childrenProps.onMouseOver) {\n        childrenProps.onMouseOver(event);\n      }\n\n      if (this.ignoreNonTouchEvents && event.type !== 'touchstart') {\n        return;\n      } // Remove the title ahead of time.\n      // We don't want to wait for the next render commit.\n      // We would risk displaying two tooltips at the same time (native + this one).\n\n\n      this.childrenRef.setAttribute('title', '');\n      clearTimeout(this.enterTimer);\n      clearTimeout(this.leaveTimer);\n\n      if (enterDelay) {\n        event.persist();\n        this.enterTimer = setTimeout(() => {\n          this.handleOpen(event);\n        }, enterDelay);\n      } else {\n        this.handleOpen(event);\n      }\n    };\n\n    this.handleOpen = event => {\n      // The mouseover event will trigger for every nested element in the tooltip.\n      // We can skip rerendering when the tooltip is already open.\n      // We are using the mouseover event instead of the mouseenter event to fix a hide/show issue.\n      if (!this.isControlled && !this.state.open) {\n        this.setState({\n          open: true\n        });\n      }\n\n      if (this.props.onOpen) {\n        this.props.onOpen(event);\n      }\n    };\n\n    this.handleLeave = event => {\n      const _this$props3 = this.props,\n            children = _this$props3.children,\n            leaveDelay = _this$props3.leaveDelay;\n      const childrenProps = children.props;\n\n      if (event.type === 'blur' && childrenProps.onBlur) {\n        childrenProps.onBlur(event);\n      }\n\n      if (event.type === 'mouseleave' && childrenProps.onMouseLeave) {\n        childrenProps.onMouseLeave(event);\n      }\n\n      clearTimeout(this.enterTimer);\n      clearTimeout(this.leaveTimer);\n\n      if (leaveDelay) {\n        event.persist();\n        this.leaveTimer = setTimeout(() => {\n          this.handleClose(event);\n        }, leaveDelay);\n      } else {\n        this.handleClose(event);\n      }\n    };\n\n    this.handleClose = event => {\n      if (!this.isControlled) {\n        this.setState({\n          open: false\n        });\n      }\n\n      if (this.props.onClose) {\n        this.props.onClose(event);\n      }\n\n      clearTimeout(this.closeTimer);\n      this.closeTimer = setTimeout(() => {\n        this.ignoreNonTouchEvents = false;\n      }, this.props.theme.transitions.duration.shortest);\n    };\n\n    this.handleTouchStart = event => {\n      this.ignoreNonTouchEvents = true;\n      const _this$props4 = this.props,\n            children = _this$props4.children,\n            enterTouchDelay = _this$props4.enterTouchDelay;\n\n      if (children.props.onTouchStart) {\n        children.props.onTouchStart(event);\n      }\n\n      clearTimeout(this.leaveTimer);\n      clearTimeout(this.closeTimer);\n      clearTimeout(this.touchTimer);\n      event.persist();\n      this.touchTimer = setTimeout(() => {\n        this.handleEnter(event);\n      }, enterTouchDelay);\n    };\n\n    this.handleTouchEnd = event => {\n      const _this$props5 = this.props,\n            children = _this$props5.children,\n            leaveTouchDelay = _this$props5.leaveTouchDelay;\n\n      if (children.props.onTouchEnd) {\n        children.props.onTouchEnd(event);\n      }\n\n      clearTimeout(this.touchTimer);\n      clearTimeout(this.leaveTimer);\n      event.persist();\n      this.leaveTimer = setTimeout(() => {\n        this.handleClose(event);\n      }, leaveTouchDelay);\n    };\n\n    this.isControlled = props.open != null;\n    this.state = {\n      open: null\n    };\n\n    if (!this.isControlled) {\n      // not controlled, use internal state\n      this.state.open = false;\n    }\n  }\n\n  componentDidMount() {\n    process.env.NODE_ENV !== \"production\" ? warning(!this.childrenRef.disabled || this.childrenRef.disabled && this.props.title === '' || this.childrenRef.tagName.toLowerCase() !== 'button', ['Material-UI: you are providing a disabled `button` child to the Tooltip component.', 'A disabled element does not fire events.', \"Tooltip needs to listen to the child element's events to display the title.\", '', 'Place a `div` container on top of the element.'].join('\\n')) : void 0; // Fallback to this default id when possible.\n    // Use the random value for client side rendering only.\n    // We can't use it server-side.\n\n    this.defaultId = \"mui-tooltip-\".concat(Math.round(Math.random() * 1e5)); // Rerender with this.defaultId and this.childrenRef.\n\n    if (this.props.open) {\n      this.forceUpdate();\n    }\n  }\n\n  componentWillUnmount() {\n    clearTimeout(this.closeTimer);\n    clearTimeout(this.enterTimer);\n    clearTimeout(this.focusTimer);\n    clearTimeout(this.leaveTimer);\n    clearTimeout(this.touchTimer);\n  }\n\n  render() {\n    const _this$props = this.props,\n          children = _this$props.children,\n          classes = _this$props.classes,\n          disableFocusListener = _this$props.disableFocusListener,\n          disableHoverListener = _this$props.disableHoverListener,\n          disableTouchListener = _this$props.disableTouchListener,\n          id = _this$props.id,\n          interactive = _this$props.interactive,\n          openProp = _this$props.open,\n          placement = _this$props.placement,\n          PopperProps = _this$props.PopperProps,\n          theme = _this$props.theme,\n          title = _this$props.title,\n          TransitionComponent = _this$props.TransitionComponent,\n          TransitionProps = _this$props.TransitionProps,\n          other = _objectWithoutPropertiesLoose(_this$props, [\"children\", \"classes\", \"disableFocusListener\", \"disableHoverListener\", \"disableTouchListener\", \"enterDelay\", \"enterTouchDelay\", \"id\", \"interactive\", \"leaveDelay\", \"leaveTouchDelay\", \"onClose\", \"onOpen\", \"open\", \"placement\", \"PopperProps\", \"theme\", \"title\", \"TransitionComponent\", \"TransitionProps\"]);\n\n    let open = this.isControlled ? openProp : this.state.open; // There is no point in displaying an empty tooltip.\n\n    if (title === '') {\n      open = false;\n    } // For accessibility and SEO concerns, we render the title to the DOM node when\n    // the tooltip is hidden. However, we have made a tradeoff when\n    // `disableHoverListener` is set. This title logic is disabled.\n    // It's allowing us to keep the implementation size minimal.\n    // We are open to change the tradeoff.\n\n\n    const shouldShowNativeTitle = !open && !disableHoverListener;\n\n    const childrenProps = _extends({\n      'aria-describedby': open ? id || this.defaultId : null,\n      title: shouldShowNativeTitle && typeof title === 'string' ? title : null\n    }, other, children.props, {\n      className: classNames(other.className, children.props.className)\n    });\n\n    if (!disableTouchListener) {\n      childrenProps.onTouchStart = this.handleTouchStart;\n      childrenProps.onTouchEnd = this.handleTouchEnd;\n    }\n\n    if (!disableHoverListener) {\n      childrenProps.onMouseOver = this.handleEnter;\n      childrenProps.onMouseLeave = this.handleLeave;\n    }\n\n    if (!disableFocusListener) {\n      childrenProps.onFocus = this.handleFocus;\n      childrenProps.onBlur = this.handleLeave;\n    }\n\n    const interactiveWrapperListeners = interactive ? {\n      onMouseOver: childrenProps.onMouseOver,\n      onMouseLeave: childrenProps.onMouseLeave,\n      onFocus: childrenProps.onFocus,\n      onBlur: childrenProps.onBlur\n    } : {};\n    process.env.NODE_ENV !== \"production\" ? warning(!children.props.title, ['Material-UI: you have provided a `title` property to the child of <Tooltip />.', \"Remove this title property `\".concat(children.props.title, \"` or the Tooltip component.\")].join('\\n')) : void 0;\n    return React.createElement(React.Fragment, null, React.createElement(RootRef, {\n      rootRef: this.onRootRef\n    }, React.cloneElement(children, childrenProps)), React.createElement(Popper, _extends({\n      className: classNames(classes.popper, {\n        [classes.popperInteractive]: interactive\n      }),\n      placement: placement,\n      anchorEl: this.childrenRef,\n      open: open,\n      id: childrenProps['aria-describedby'],\n      transition: true\n    }, interactiveWrapperListeners, PopperProps), ({\n      placement: placementInner,\n      TransitionProps: TransitionPropsInner\n    }) => React.createElement(TransitionComponent, _extends({\n      timeout: theme.transitions.duration.shorter\n    }, TransitionPropsInner, TransitionProps), React.createElement(\"div\", {\n      className: classNames(classes.tooltip, {\n        [classes.touch]: this.ignoreNonTouchEvents\n      }, classes[\"tooltipPlacement\".concat(capitalize(placementInner.split('-')[0]))])\n    }, title))));\n  }\n\n}\n\nprocess.env.NODE_ENV !== \"production\" ? Tooltip.propTypes = {\n  /**\n   * Tooltip reference element.\n   */\n  children: PropTypes.element.isRequired,\n\n  /**\n   * Override or extend the styles applied to the component.\n   * See [CSS API](#css-api) below for more details.\n   */\n  classes: PropTypes.object.isRequired,\n\n  /**\n   * Do not respond to focus events.\n   */\n  disableFocusListener: PropTypes.bool,\n\n  /**\n   * Do not respond to hover events.\n   */\n  disableHoverListener: PropTypes.bool,\n\n  /**\n   * Do not respond to long press touch events.\n   */\n  disableTouchListener: PropTypes.bool,\n\n  /**\n   * The number of milliseconds to wait before showing the tooltip.\n   * This property won't impact the enter touch delay (`enterTouchDelay`).\n   */\n  enterDelay: PropTypes.number,\n\n  /**\n   * The number of milliseconds a user must touch the element before showing the tooltip.\n   */\n  enterTouchDelay: PropTypes.number,\n\n  /**\n   * The relationship between the tooltip and the wrapper component is not clear from the DOM.\n   * This property is used with aria-describedby to solve the accessibility issue.\n   * If you don't provide this property. It falls back to a randomly generated id.\n   */\n  id: PropTypes.string,\n\n  /**\n   * Makes a tooltip interactive, i.e. will not close when the user\n   * hovers over the tooltip before the `leaveDelay` is expired.\n   */\n  interactive: PropTypes.bool,\n\n  /**\n   * The number of milliseconds to wait before hiding the tooltip.\n   * This property won't impact the leave touch delay (`leaveTouchDelay`).\n   */\n  leaveDelay: PropTypes.number,\n\n  /**\n   * The number of milliseconds after the user stops touching an element before hiding the tooltip.\n   */\n  leaveTouchDelay: PropTypes.number,\n\n  /**\n   * Callback fired when the tooltip requests to be closed.\n   *\n   * @param {object} event The event source of the callback\n   */\n  onClose: PropTypes.func,\n\n  /**\n   * Callback fired when the tooltip requests to be open.\n   *\n   * @param {object} event The event source of the callback\n   */\n  onOpen: PropTypes.func,\n\n  /**\n   * If `true`, the tooltip is shown.\n   */\n  open: PropTypes.bool,\n\n  /**\n   * Tooltip placement.\n   */\n  placement: PropTypes.oneOf(['bottom-end', 'bottom-start', 'bottom', 'left-end', 'left-start', 'left', 'right-end', 'right-start', 'right', 'top-end', 'top-start', 'top']),\n\n  /**\n   * Properties applied to the [`Popper`](/api/popper/) element.\n   */\n  PopperProps: PropTypes.object,\n\n  /**\n   * @ignore\n   */\n  theme: PropTypes.object.isRequired,\n\n  /**\n   * Tooltip title. Zero-length titles string are never displayed.\n   */\n  title: PropTypes.node.isRequired,\n\n  /**\n   * The component used for the transition.\n   */\n  TransitionComponent: componentPropType,\n\n  /**\n   * Properties applied to the `Transition` element.\n   */\n  TransitionProps: PropTypes.object\n} : void 0;\nTooltip.defaultProps = {\n  disableFocusListener: false,\n  disableHoverListener: false,\n  disableTouchListener: false,\n  enterDelay: 0,\n  enterTouchDelay: 1000,\n  interactive: false,\n  leaveDelay: 0,\n  leaveTouchDelay: 1500,\n  placement: 'bottom',\n  TransitionComponent: Grow\n};\nexport default withStyles(styles, {\n  name: 'MuiTooltip',\n  withTheme: true\n})(Tooltip);","map":null,"metadata":{},"sourceType":"module"}