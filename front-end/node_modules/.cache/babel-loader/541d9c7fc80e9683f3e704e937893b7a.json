{"ast":null,"code":"import _extends from \"@babel/runtime/helpers/extends\";\nimport _objectWithoutPropertiesLoose from \"@babel/runtime/helpers/objectWithoutPropertiesLoose\"; // @inheritedComponent FormGroup\n\nimport React from 'react';\nimport PropTypes from 'prop-types';\nimport warning from 'warning';\nimport FormGroup from '../FormGroup';\nimport { createChainedFunction, find } from '../utils/helpers';\n\nclass RadioGroup extends React.Component {\n  constructor(props) {\n    super();\n    this.radios = [];\n\n    this.focus = () => {\n      if (!this.radios || !this.radios.length) {\n        return;\n      }\n\n      const focusRadios = this.radios.filter(n => !n.disabled);\n\n      if (!focusRadios.length) {\n        return;\n      }\n\n      const selectedRadio = find(focusRadios, n => n.checked);\n\n      if (selectedRadio) {\n        selectedRadio.focus();\n        return;\n      }\n\n      focusRadios[0].focus();\n    };\n\n    this.handleChange = event => {\n      if (!this.isControlled) {\n        this.setState({\n          value: event.target.value\n        });\n      }\n\n      if (this.props.onChange) {\n        this.props.onChange(event, event.target.value);\n      }\n    };\n\n    this.isControlled = props.value != null;\n\n    if (!this.isControlled) {\n      this.state = {\n        value: props.defaultValue\n      };\n    }\n  }\n\n  render() {\n    const _this$props = this.props,\n          children = _this$props.children,\n          name = _this$props.name,\n          valueProp = _this$props.value,\n          other = _objectWithoutPropertiesLoose(_this$props, [\"children\", \"name\", \"value\", \"onChange\"]);\n\n    const value = this.isControlled ? valueProp : this.state.value;\n    this.radios = [];\n    return React.createElement(FormGroup, _extends({\n      role: \"radiogroup\"\n    }, other), React.Children.map(children, child => {\n      if (!React.isValidElement(child)) {\n        return null;\n      }\n\n      process.env.NODE_ENV !== \"production\" ? warning(child.type !== React.Fragment, [\"Material-UI: the RadioGroup component doesn't accept a Fragment as a child.\", 'Consider providing an array instead.'].join('\\n')) : void 0;\n      return React.cloneElement(child, {\n        name,\n        inputRef: node => {\n          if (node) {\n            this.radios.push(node);\n          }\n        },\n        checked: value === child.props.value,\n        onChange: createChainedFunction(child.props.onChange, this.handleChange)\n      });\n    }));\n  }\n\n}\n\nprocess.env.NODE_ENV !== \"production\" ? RadioGroup.propTypes = {\n  /**\n   * The content of the component.\n   */\n  children: PropTypes.node,\n\n  /**\n   * The default input value, useful when not controlling the component.\n   */\n  defaultValue: PropTypes.oneOfType([PropTypes.string, PropTypes.number, PropTypes.bool]),\n\n  /**\n   * The name used to reference the value of the control.\n   */\n  name: PropTypes.string,\n\n  /**\n   * @ignore\n   */\n  onBlur: PropTypes.func,\n\n  /**\n   * Callback fired when a radio button is selected.\n   *\n   * @param {object} event The event source of the callback.\n   * You can pull out the new value by accessing `event.target.value`.\n   * @param {string} value The `value` of the selected radio button\n   */\n  onChange: PropTypes.func,\n\n  /**\n   * @ignore\n   */\n  onKeyDown: PropTypes.func,\n\n  /**\n   * Value of the selected radio button.\n   */\n  value: PropTypes.oneOfType([PropTypes.string, PropTypes.number, PropTypes.bool])\n} : void 0;\nexport default RadioGroup;","map":null,"metadata":{},"sourceType":"module"}