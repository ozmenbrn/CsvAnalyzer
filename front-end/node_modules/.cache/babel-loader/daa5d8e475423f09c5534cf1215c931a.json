{"ast":null,"code":"import _extends from \"@babel/runtime/helpers/extends\";\nimport _objectWithoutPropertiesLoose from \"@babel/runtime/helpers/objectWithoutPropertiesLoose\";\n/* eslint-disable consistent-this */\n// @inheritedComponent Drawer\n\nimport React from 'react';\nimport PropTypes from 'prop-types';\nimport ReactDOM from 'react-dom';\nimport Drawer, { getAnchor, isHorizontal } from '../Drawer/Drawer';\nimport { duration } from '../styles/transitions';\nimport withTheme from '../styles/withTheme';\nimport { getTransitionProps } from '../transitions/utils';\nimport NoSsr from '../NoSsr';\nimport SwipeArea from './SwipeArea'; // This value is closed to what browsers are using internally to\n// trigger a native scroll.\n\nconst UNCERTAINTY_THRESHOLD = 3; // px\n// We can only have one node at the time claiming ownership for handling the swipe.\n// Otherwise, the UX would be confusing.\n// That's why we use a singleton here.\n\nlet nodeThatClaimedTheSwipe = null; // Exported for test purposes.\n\nexport function reset() {\n  nodeThatClaimedTheSwipe = null;\n}\n/* istanbul ignore if */\n\nif (process.env.NODE_ENV !== 'production' && !React.createContext) {\n  throw new Error('Material-UI: react@16.3.0 or greater is required.');\n}\n\nclass SwipeableDrawer extends React.Component {\n  constructor(...args) {\n    super(...args);\n    this.state = {};\n    this.isSwiping = null;\n    this.swipeAreaRef = React.createRef();\n\n    this.handleBodyTouchStart = event => {\n      // We are not supposed to handle this touch move.\n      if (nodeThatClaimedTheSwipe !== null && nodeThatClaimedTheSwipe !== this) {\n        return;\n      }\n\n      const _this$props2 = this.props,\n            disableDiscovery = _this$props2.disableDiscovery,\n            disableSwipeToOpen = _this$props2.disableSwipeToOpen,\n            open = _this$props2.open,\n            swipeAreaWidth = _this$props2.swipeAreaWidth;\n      const anchor = getAnchor(this.props);\n      const currentX = anchor === 'right' ? document.body.offsetWidth - event.touches[0].pageX : event.touches[0].pageX;\n      const currentY = anchor === 'bottom' ? window.innerHeight - event.touches[0].clientY : event.touches[0].clientY;\n\n      if (!open) {\n        if (disableSwipeToOpen || event.target !== this.swipeAreaRef.current) {\n          return;\n        }\n\n        if (isHorizontal(this.props)) {\n          if (currentX > swipeAreaWidth) {\n            return;\n          }\n        } else if (currentY > swipeAreaWidth) {\n          return;\n        }\n      }\n\n      nodeThatClaimedTheSwipe = this;\n      this.startX = currentX;\n      this.startY = currentY;\n      this.setState({\n        maybeSwiping: true\n      });\n\n      if (!open && this.paperRef) {\n        // The ref may be null when a parent component updates while swiping.\n        this.setPosition(this.getMaxTranslate() + (disableDiscovery ? 20 : -swipeAreaWidth), {\n          changeTransition: false\n        });\n      }\n\n      this.velocity = 0;\n      this.lastTime = null;\n      this.lastTranslate = null;\n      document.body.addEventListener('touchmove', this.handleBodyTouchMove, {\n        passive: false\n      });\n      document.body.addEventListener('touchend', this.handleBodyTouchEnd); // https://plus.google.com/+PaulIrish/posts/KTwfn1Y2238\n\n      document.body.addEventListener('touchcancel', this.handleBodyTouchEnd);\n    };\n\n    this.handleBodyTouchMove = event => {\n      // The ref may be null when a parent component updates while swiping.\n      if (!this.paperRef) return;\n      const anchor = getAnchor(this.props);\n      const horizontalSwipe = isHorizontal(this.props);\n      const currentX = anchor === 'right' ? document.body.offsetWidth - event.touches[0].pageX : event.touches[0].pageX;\n      const currentY = anchor === 'bottom' ? window.innerHeight - event.touches[0].clientY : event.touches[0].clientY; // We don't know yet.\n\n      if (this.isSwiping == null) {\n        const dx = Math.abs(currentX - this.startX);\n        const dy = Math.abs(currentY - this.startY); // We are likely to be swiping, let's prevent the scroll event on iOS.\n\n        if (dx > dy) {\n          event.preventDefault();\n        }\n\n        const isSwiping = horizontalSwipe ? dx > dy && dx > UNCERTAINTY_THRESHOLD : dy > dx && dy > UNCERTAINTY_THRESHOLD;\n\n        if (isSwiping === true || (horizontalSwipe ? dy > UNCERTAINTY_THRESHOLD : dx > UNCERTAINTY_THRESHOLD)) {\n          this.isSwiping = isSwiping;\n\n          if (!isSwiping) {\n            this.handleBodyTouchEnd(event);\n            return;\n          } // Shift the starting point.\n\n\n          this.startX = currentX;\n          this.startY = currentY; // Compensate for the part of the drawer displayed on touch start.\n\n          if (!this.props.disableDiscovery && !this.props.open) {\n            if (horizontalSwipe) {\n              this.startX -= this.props.swipeAreaWidth;\n            } else {\n              this.startY -= this.props.swipeAreaWidth;\n            }\n          }\n        }\n      }\n\n      if (!this.isSwiping) {\n        return;\n      }\n\n      const translate = this.getTranslate(horizontalSwipe ? currentX : currentY);\n\n      if (this.lastTranslate === null) {\n        this.lastTranslate = translate;\n        this.lastTime = performance.now() + 1;\n      }\n\n      const velocity = (translate - this.lastTranslate) / (performance.now() - this.lastTime) * 1e3; // Low Pass filter.\n\n      this.velocity = this.velocity * 0.4 + velocity * 0.6;\n      this.lastTranslate = translate;\n      this.lastTime = performance.now(); // We are swiping, let's prevent the scroll event on iOS.\n\n      event.preventDefault();\n      this.setPosition(translate);\n    };\n\n    this.handleBodyTouchEnd = event => {\n      nodeThatClaimedTheSwipe = null;\n      this.removeBodyTouchListeners();\n      this.setState({\n        maybeSwiping: false\n      }); // The swipe wasn't started.\n\n      if (!this.isSwiping) {\n        this.isSwiping = null;\n        return;\n      }\n\n      this.isSwiping = null;\n      const anchor = getAnchor(this.props);\n      let current;\n\n      if (isHorizontal(this.props)) {\n        current = anchor === 'right' ? document.body.offsetWidth - event.changedTouches[0].pageX : event.changedTouches[0].pageX;\n      } else {\n        current = anchor === 'bottom' ? window.innerHeight - event.changedTouches[0].clientY : event.changedTouches[0].clientY;\n      }\n\n      const translateRatio = this.getTranslate(current) / this.getMaxTranslate();\n\n      if (this.props.open) {\n        if (this.velocity > this.props.minFlingVelocity || translateRatio > this.props.hysteresis) {\n          this.props.onClose();\n        } else {\n          // Reset the position, the swipe was aborted.\n          this.setPosition(0, {\n            mode: 'exit'\n          });\n        }\n\n        return;\n      }\n\n      if (this.velocity < -this.props.minFlingVelocity || 1 - translateRatio > this.props.hysteresis) {\n        this.props.onOpen();\n      } else {\n        // Reset the position, the swipe was aborted.\n        this.setPosition(this.getMaxTranslate(), {\n          mode: 'enter'\n        });\n      }\n    };\n\n    this.handleBackdropRef = ref => {\n      this.backdropRef = ref ? ReactDOM.findDOMNode(ref) : null;\n    };\n\n    this.handlePaperRef = ref => {\n      this.paperRef = ref ? ReactDOM.findDOMNode(ref) : null;\n    };\n  }\n\n  componentDidMount() {\n    if (this.props.variant === 'temporary') {\n      this.listenTouchStart();\n    }\n  }\n\n  componentDidUpdate(prevProps) {\n    const variant = this.props.variant;\n    const prevVariant = prevProps.variant;\n\n    if (variant !== prevVariant) {\n      if (variant === 'temporary') {\n        this.listenTouchStart();\n      } else if (prevVariant === 'temporary') {\n        this.removeTouchStart();\n      }\n    }\n  }\n\n  componentWillUnmount() {\n    this.removeTouchStart();\n    this.removeBodyTouchListeners(); // We need to release the lock.\n\n    if (nodeThatClaimedTheSwipe === this) {\n      nodeThatClaimedTheSwipe = null;\n    }\n  }\n\n  static getDerivedStateFromProps(nextProps, prevState) {\n    if (typeof prevState.maybeSwiping === 'undefined') {\n      return {\n        maybeSwiping: false,\n        open: nextProps.open\n      };\n    }\n\n    if (!nextProps.open && prevState.open) {\n      return {\n        maybeSwiping: false,\n        open: nextProps.open\n      };\n    }\n\n    return {\n      open: nextProps.open\n    };\n  }\n\n  getMaxTranslate() {\n    return isHorizontal(this.props) ? this.paperRef.clientWidth : this.paperRef.clientHeight;\n  }\n\n  getTranslate(current) {\n    const start = isHorizontal(this.props) ? this.startX : this.startY;\n    return Math.min(Math.max(this.props.open ? start - current : this.getMaxTranslate() + start - current, 0), this.getMaxTranslate());\n  }\n\n  setPosition(translate, options = {}) {\n    const _options$mode = options.mode,\n          mode = _options$mode === void 0 ? null : _options$mode,\n          _options$changeTransi = options.changeTransition,\n          changeTransition = _options$changeTransi === void 0 ? true : _options$changeTransi;\n    const anchor = getAnchor(this.props);\n    const rtlTranslateMultiplier = ['right', 'bottom'].indexOf(anchor) !== -1 ? 1 : -1;\n    const transform = isHorizontal(this.props) ? \"translate(\".concat(rtlTranslateMultiplier * translate, \"px, 0)\") : \"translate(0, \".concat(rtlTranslateMultiplier * translate, \"px)\");\n    const drawerStyle = this.paperRef.style;\n    drawerStyle.webkitTransform = transform;\n    drawerStyle.transform = transform;\n    let transition = '';\n\n    if (mode) {\n      transition = this.props.theme.transitions.create('all', getTransitionProps({\n        timeout: this.props.transitionDuration\n      }, {\n        mode\n      }));\n    }\n\n    if (changeTransition) {\n      drawerStyle.webkitTransition = transition;\n      drawerStyle.transition = transition;\n    }\n\n    if (!this.props.disableBackdropTransition && !this.props.hideBackdrop) {\n      const backdropStyle = this.backdropRef.style;\n      backdropStyle.opacity = 1 - translate / this.getMaxTranslate();\n\n      if (changeTransition) {\n        backdropStyle.webkitTransition = transition;\n        backdropStyle.transition = transition;\n      }\n    }\n  }\n\n  listenTouchStart() {\n    document.body.addEventListener('touchstart', this.handleBodyTouchStart);\n  }\n\n  removeTouchStart() {\n    document.body.removeEventListener('touchstart', this.handleBodyTouchStart);\n  }\n\n  removeBodyTouchListeners() {\n    document.body.removeEventListener('touchmove', this.handleBodyTouchMove, {\n      passive: false\n    });\n    document.body.removeEventListener('touchend', this.handleBodyTouchEnd);\n    document.body.removeEventListener('touchcancel', this.handleBodyTouchEnd);\n  }\n\n  render() {\n    const _this$props = this.props,\n          anchor = _this$props.anchor,\n          disableSwipeToOpen = _this$props.disableSwipeToOpen,\n          _this$props$ModalProp = _this$props.ModalProps,\n          _this$props$ModalProp2 = _this$props$ModalProp === void 0 ? {} : _this$props$ModalProp,\n          BackdropProps = _this$props$ModalProp2.BackdropProps,\n          open = _this$props.open,\n          _this$props$PaperProp = _this$props.PaperProps,\n          PaperProps = _this$props$PaperProp === void 0 ? {} : _this$props$PaperProp,\n          SwipeAreaProps = _this$props.SwipeAreaProps,\n          swipeAreaWidth = _this$props.swipeAreaWidth,\n          variant = _this$props.variant,\n          ModalPropsProp = _objectWithoutPropertiesLoose(_this$props.ModalProps, [\"BackdropProps\"]),\n          other = _objectWithoutPropertiesLoose(_this$props, [\"anchor\", \"disableBackdropTransition\", \"disableDiscovery\", \"disableSwipeToOpen\", \"hysteresis\", \"minFlingVelocity\", \"ModalProps\", \"onOpen\", \"open\", \"PaperProps\", \"SwipeAreaProps\", \"swipeAreaWidth\", \"variant\"]);\n\n    const maybeSwiping = this.state.maybeSwiping;\n    return React.createElement(React.Fragment, null, React.createElement(Drawer, _extends({\n      open: variant === 'temporary' && maybeSwiping ? true : open,\n      variant: variant,\n      ModalProps: _extends({\n        BackdropProps: _extends({}, BackdropProps, {\n          ref: this.handleBackdropRef\n        })\n      }, ModalPropsProp),\n      PaperProps: _extends({}, PaperProps, {\n        style: _extends({\n          pointerEvents: variant === 'temporary' && !open ? 'none' : ''\n        }, PaperProps.style),\n        ref: this.handlePaperRef\n      }),\n      anchor: anchor\n    }, other)), !disableSwipeToOpen && variant === 'temporary' && React.createElement(NoSsr, null, React.createElement(SwipeArea, _extends({\n      anchor: anchor,\n      innerRef: this.swipeAreaRef,\n      width: swipeAreaWidth\n    }, SwipeAreaProps))));\n  }\n\n}\n\nprocess.env.NODE_ENV !== \"production\" ? SwipeableDrawer.propTypes = {\n  /**\n   * @ignore\n   */\n  anchor: PropTypes.oneOf(['left', 'top', 'right', 'bottom']),\n\n  /**\n   * Disable the backdrop transition.\n   * This can improve the FPS on low-end devices.\n   */\n  disableBackdropTransition: PropTypes.bool,\n\n  /**\n   * If `true`, touching the screen near the edge of the drawer will not slide in the drawer a bit\n   * to promote accidental discovery of the swipe gesture.\n   */\n  disableDiscovery: PropTypes.bool,\n\n  /**\n   * If `true`, swipe to open is disabled. This is useful in browsers where swiping triggers\n   * navigation actions. Swipe to open is disabled on iOS browsers by default.\n   */\n  disableSwipeToOpen: PropTypes.bool,\n\n  /**\n   * @ignore\n   */\n  hideBackdrop: PropTypes.bool,\n\n  /**\n   * Affects how far the drawer must be opened/closed to change his state.\n   * Specified as percent (0-1) of the width of the drawer\n   */\n  hysteresis: PropTypes.number,\n\n  /**\n   * Defines, from which (average) velocity on, the swipe is\n   * defined as complete although hysteresis isn't reached.\n   * Good threshold is between 250 - 1000 px/s\n   */\n  minFlingVelocity: PropTypes.number,\n\n  /**\n   * @ignore\n   */\n  ModalProps: PropTypes.object,\n\n  /**\n   * Callback fired when the component requests to be closed.\n   *\n   * @param {object} event The event source of the callback\n   */\n  onClose: PropTypes.func.isRequired,\n\n  /**\n   * Callback fired when the component requests to be opened.\n   *\n   * @param {object} event The event source of the callback\n   */\n  onOpen: PropTypes.func.isRequired,\n\n  /**\n   * If `true`, the drawer is open.\n   */\n  open: PropTypes.bool.isRequired,\n\n  /**\n   * @ignore\n   */\n  PaperProps: PropTypes.object,\n\n  /**\n   * Properties applied to the swipe area element.\n   */\n  SwipeAreaProps: PropTypes.object,\n\n  /**\n   * The width of the left most (or right most) area in pixels where the\n   * drawer can be swiped open from.\n   */\n  swipeAreaWidth: PropTypes.number,\n\n  /**\n   * @ignore\n   */\n  theme: PropTypes.object.isRequired,\n\n  /**\n   * The duration for the transition, in milliseconds.\n   * You may specify a single timeout for all transitions, or individually with an object.\n   */\n  transitionDuration: PropTypes.oneOfType([PropTypes.number, PropTypes.shape({\n    enter: PropTypes.number,\n    exit: PropTypes.number\n  })]),\n\n  /**\n   * @ignore\n   */\n  variant: PropTypes.oneOf(['permanent', 'persistent', 'temporary'])\n} : void 0;\nSwipeableDrawer.defaultProps = {\n  anchor: 'left',\n  disableBackdropTransition: false,\n  disableDiscovery: false,\n  disableSwipeToOpen: typeof navigator !== 'undefined' && /iPad|iPhone|iPod/.test(navigator.userAgent),\n  hysteresis: 0.55,\n  minFlingVelocity: 400,\n  swipeAreaWidth: 20,\n  transitionDuration: {\n    enter: duration.enteringScreen,\n    exit: duration.leavingScreen\n  },\n  variant: 'temporary' // Mobile first.\n\n};\nexport default withTheme()(SwipeableDrawer);","map":null,"metadata":{},"sourceType":"module"}