{"ast":null,"code":"import _extends from \"@babel/runtime/helpers/extends\";\nimport _objectWithoutPropertiesLoose from \"@babel/runtime/helpers/objectWithoutPropertiesLoose\";\nimport React from 'react';\nimport PropTypes from 'prop-types';\nimport classnames from 'classnames';\nimport debounce from 'debounce'; // < 1kb payload overhead when lodash/debounce is > 3kb.\n\nimport EventListener from 'react-event-listener';\nimport withStyles from '../styles/withStyles';\nimport { setRef } from '../utils/reactHelpers';\nconst ROWS_HEIGHT = 19;\nexport const styles = {\n  /* Styles applied to the root element. */\n  root: {\n    position: 'relative',\n    // because the shadow has position: 'absolute',\n    width: '100%'\n  },\n  textarea: {\n    width: '100%',\n    height: '100%',\n    resize: 'none',\n    font: 'inherit',\n    padding: 0,\n    cursor: 'inherit',\n    boxSizing: 'border-box',\n    lineHeight: 'inherit',\n    border: 'none',\n    outline: 'none',\n    background: 'transparent'\n  },\n  shadow: {\n    // Overflow also needed to here to remove the extra row\n    // added to textareas in Firefox.\n    overflow: 'hidden',\n    // Visibility needed to hide the extra text area on iPads\n    visibility: 'hidden',\n    position: 'absolute',\n    height: 'auto',\n    whiteSpace: 'pre-wrap'\n  }\n};\n/**\n * @ignore - internal component.\n */\n\nclass Textarea extends React.Component {\n  constructor(props) {\n    super();\n\n    this.handleRefInput = ref => {\n      this.inputRef = ref;\n      setRef(this.props.textareaRef, ref);\n    };\n\n    this.handleRefSinglelineShadow = ref => {\n      this.singlelineShadowRef = ref;\n    };\n\n    this.handleRefShadow = ref => {\n      this.shadowRef = ref;\n    };\n\n    this.handleChange = event => {\n      this.value = event.target.value;\n\n      if (!this.isControlled) {\n        // The component is not controlled, we need to update the shallow value.\n        this.shadowRef.value = this.value;\n        this.syncHeightWithShadow();\n      }\n\n      if (this.props.onChange) {\n        this.props.onChange(event);\n      }\n    };\n\n    this.isControlled = props.value != null; // <Input> expects the components it renders to respond to 'value'\n    // so that it can check whether they are filled.\n\n    this.value = props.value || props.defaultValue || '';\n    this.state = {\n      height: Number(props.rows) * ROWS_HEIGHT\n    };\n\n    if (typeof window !== 'undefined') {\n      this.handleResize = debounce(() => {\n        this.syncHeightWithShadow();\n      }, 166); // Corresponds to 10 frames at 60 Hz.\n    }\n  }\n\n  componentDidMount() {\n    this.syncHeightWithShadow();\n  }\n\n  componentDidUpdate() {\n    this.syncHeightWithShadow();\n  }\n\n  componentWillUnmount() {\n    this.handleResize.clear();\n  }\n\n  syncHeightWithShadow() {\n    const props = this.props; // Guarding for **broken** shallow rendering method that call componentDidMount\n    // but doesn't handle refs correctly.\n    // To remove once the shallow rendering has been fixed.\n\n    if (!this.shadowRef) {\n      return;\n    }\n\n    if (this.isControlled) {\n      // The component is controlled, we need to update the shallow value.\n      this.shadowRef.value = props.value == null ? '' : String(props.value);\n    }\n\n    let lineHeight = this.singlelineShadowRef.scrollHeight; // The Textarea might not be visible (p.ex: display: none).\n    // In this case, the layout values read from the DOM will be 0.\n\n    lineHeight = lineHeight === 0 ? ROWS_HEIGHT : lineHeight;\n    let newHeight = this.shadowRef.scrollHeight; // Guarding for jsdom, where scrollHeight isn't present.\n    // See https://github.com/tmpvar/jsdom/issues/1013\n\n    if (newHeight === undefined) {\n      return;\n    }\n\n    if (Number(props.rowsMax) >= Number(props.rows)) {\n      newHeight = Math.min(Number(props.rowsMax) * lineHeight, newHeight);\n    }\n\n    newHeight = Math.max(newHeight, lineHeight); // Need a large enough different to update the height.\n    // This prevents infinite rendering loop.\n\n    if (Math.abs(this.state.height - newHeight) > 1) {\n      this.setState({\n        height: newHeight\n      });\n    }\n  }\n\n  render() {\n    const _this$props = this.props,\n          classes = _this$props.classes,\n          className = _this$props.className,\n          defaultValue = _this$props.defaultValue,\n          rows = _this$props.rows,\n          style = _this$props.style,\n          value = _this$props.value,\n          other = _objectWithoutPropertiesLoose(_this$props, [\"classes\", \"className\", \"defaultValue\", \"onChange\", \"rows\", \"rowsMax\", \"style\", \"textareaRef\", \"value\"]);\n\n    return React.createElement(\"div\", {\n      className: classes.root\n    }, React.createElement(EventListener, {\n      target: \"window\",\n      onResize: this.handleResize\n    }), React.createElement(\"textarea\", {\n      \"aria-hidden\": \"true\",\n      className: classnames(classes.textarea, classes.shadow),\n      readOnly: true,\n      ref: this.handleRefSinglelineShadow,\n      rows: \"1\",\n      tabIndex: -1,\n      value: \"\"\n    }), React.createElement(\"textarea\", {\n      \"aria-hidden\": \"true\",\n      className: classnames(classes.textarea, classes.shadow),\n      defaultValue: defaultValue,\n      readOnly: true,\n      ref: this.handleRefShadow,\n      rows: rows,\n      tabIndex: -1,\n      value: value\n    }), React.createElement(\"textarea\", _extends({\n      rows: rows,\n      className: classnames(classes.textarea, className),\n      defaultValue: defaultValue,\n      value: value,\n      onChange: this.handleChange,\n      ref: this.handleRefInput,\n      style: _extends({\n        height: this.state.height\n      }, style)\n    }, other)));\n  }\n\n}\n\nprocess.env.NODE_ENV !== \"production\" ? Textarea.propTypes = {\n  /**\n   * Override or extend the styles applied to the component.\n   * See [CSS API](#css-api) below for more details.\n   */\n  classes: PropTypes.object.isRequired,\n\n  /**\n   * @ignore\n   */\n  className: PropTypes.string,\n\n  /**\n   * @ignore\n   */\n  defaultValue: PropTypes.oneOfType([PropTypes.string, PropTypes.number]),\n\n  /**\n   * @ignore\n   */\n  disabled: PropTypes.bool,\n\n  /**\n   * @ignore\n   */\n  onChange: PropTypes.func,\n\n  /**\n   * Number of rows to display when multiline option is set to true.\n   */\n  rows: PropTypes.oneOfType([PropTypes.string, PropTypes.number]),\n\n  /**\n   * Maximum number of rows to display when multiline option is set to true.\n   */\n  rowsMax: PropTypes.oneOfType([PropTypes.string, PropTypes.number]),\n\n  /**\n   * @ignore\n   */\n  style: PropTypes.object,\n\n  /**\n   * Use that property to pass a ref callback to the native textarea element.\n   */\n  textareaRef: PropTypes.oneOfType([PropTypes.func, PropTypes.object]),\n\n  /**\n   * @ignore\n   */\n  value: PropTypes.oneOfType([PropTypes.string, PropTypes.number])\n} : void 0;\nTextarea.defaultProps = {\n  rows: 1\n};\nexport default withStyles(styles, {\n  name: 'MuiPrivateTextarea'\n})(Textarea);","map":null,"metadata":{},"sourceType":"module"}