{"ast":null,"code":"import _objectWithoutPropertiesLoose from \"@babel/runtime/helpers/objectWithoutPropertiesLoose\";\nimport _extends from \"@babel/runtime/helpers/extends\"; // @inheritedComponent ButtonBase\n\nimport React from 'react';\nimport PropTypes from 'prop-types';\nimport classNames from 'classnames';\nimport withStyles from '../styles/withStyles';\nimport ButtonBase from '../ButtonBase';\nimport { capitalize } from '../utils/helpers';\nimport unsupportedProp from '../utils/unsupportedProp';\nexport const styles = theme => ({\n  /* Styles applied to the root element. */\n  root: _extends({}, theme.typography.button, {\n    maxWidth: 264,\n    minWidth: 72,\n    position: 'relative',\n    boxSizing: 'border-box',\n    padding: 0,\n    minHeight: 48,\n    flexShrink: 0,\n    overflow: 'hidden',\n    whiteSpace: 'normal',\n    textAlign: 'center',\n    [theme.breakpoints.up('md')]: {\n      fontSize: theme.typography.pxToRem(13),\n      minWidth: 160\n    }\n  }),\n\n  /* Styles applied to the root element if both `icon` and `label` are provided. */\n  labelIcon: {\n    minHeight: 72,\n    // paddingTop supposed to be 12px\n    // - 3px from the paddingBottom\n    paddingTop: 9 // paddingBottom supposed to be 12px\n    // -3px for line-height of the label\n    // -6px for label padding\n    // = 3px\n\n  },\n\n  /* Styles applied to the root element if `textColor=\"inherit\"`. */\n  textColorInherit: {\n    color: 'inherit',\n    opacity: 0.7,\n    '&$selected': {\n      opacity: 1\n    },\n    '&$disabled': {\n      opacity: 0.4\n    }\n  },\n\n  /* Styles applied to the root element if `textColor=\"primary\"`. */\n  textColorPrimary: {\n    color: theme.palette.text.secondary,\n    '&$selected': {\n      color: theme.palette.primary.main\n    },\n    '&$disabled': {\n      color: theme.palette.text.disabled\n    }\n  },\n\n  /* Styles applied to the root element if `textColor=\"secondary\"`. */\n  textColorSecondary: {\n    color: theme.palette.text.secondary,\n    '&$selected': {\n      color: theme.palette.secondary.main\n    },\n    '&$disabled': {\n      color: theme.palette.text.disabled\n    }\n  },\n\n  /* Styles applied to the root element if `selected={true}` (controlled by the Tabs component). */\n  selected: {},\n\n  /* Styles applied to the root element if `disabled={true}` (controlled by the Tabs component). */\n  disabled: {},\n\n  /* Styles applied to the root element if `fullWidth={true}` (controlled by the Tabs component). */\n  fullWidth: {\n    flexShrink: 1,\n    flexGrow: 1,\n    maxWidth: 'none'\n  },\n\n  /* Styles applied to the `icon` and `label`'s wrapper element. */\n  wrapper: {\n    display: 'inline-flex',\n    alignItems: 'center',\n    justifyContent: 'center',\n    width: '100%',\n    flexDirection: 'column'\n  },\n\n  /* Styles applied to the label container element if `label` is provided. */\n  labelContainer: {\n    width: '100%',\n    // Fix an IE 11 issue\n    boxSizing: 'border-box',\n    padding: '6px 12px',\n    [theme.breakpoints.up('md')]: {\n      padding: '6px 24px'\n    }\n  },\n\n  /* Styles applied to the label wrapper element if `label` is provided. */\n  label: {},\n\n  /* Deprecated, the styles will be removed in v4. */\n  labelWrapped: {}\n});\n\nclass Tab extends React.Component {\n  constructor(...args) {\n    super(...args);\n    this.state = {\n      labelWrapped: false\n    };\n\n    this.handleChange = event => {\n      const _this$props2 = this.props,\n            onChange = _this$props2.onChange,\n            value = _this$props2.value,\n            onClick = _this$props2.onClick;\n\n      if (onChange) {\n        onChange(event, value);\n      }\n\n      if (onClick) {\n        onClick(event);\n      }\n    };\n\n    this.checkTextWrap = () => {\n      if (this.labelRef) {\n        const labelWrapped = this.labelRef.getClientRects().length > 1;\n\n        if (this.state.labelWrapped !== labelWrapped) {\n          this.setState({\n            labelWrapped\n          });\n        }\n      }\n    };\n  }\n\n  componentDidMount() {\n    this.checkTextWrap();\n  }\n\n  componentDidUpdate(prevProps, prevState) {\n    if (this.state.labelWrapped === prevState.labelWrapped) {\n      /**\n       * At certain text and tab lengths, a larger font size may wrap to two lines while the smaller\n       * font size still only requires one line.  This check will prevent an infinite render loop\n       * from occurring in that scenario.\n       */\n      this.checkTextWrap();\n    }\n  }\n\n  render() {\n    const _this$props = this.props,\n          classes = _this$props.classes,\n          className = _this$props.className,\n          disabled = _this$props.disabled,\n          fullWidth = _this$props.fullWidth,\n          icon = _this$props.icon,\n          indicator = _this$props.indicator,\n          labelProp = _this$props.label,\n          selected = _this$props.selected,\n          textColor = _this$props.textColor,\n          other = _objectWithoutPropertiesLoose(_this$props, [\"classes\", \"className\", \"disabled\", \"fullWidth\", \"icon\", \"indicator\", \"label\", \"onChange\", \"selected\", \"textColor\", \"value\"]);\n\n    let label;\n\n    if (labelProp !== undefined) {\n      label = React.createElement(\"span\", {\n        className: classes.labelContainer\n      }, React.createElement(\"span\", {\n        className: classNames(classes.label, {\n          [classes.labelWrapped]: this.state.labelWrapped\n        }),\n        ref: ref => {\n          this.labelRef = ref;\n        }\n      }, labelProp));\n    }\n\n    return React.createElement(ButtonBase, _extends({\n      focusRipple: true,\n      className: classNames(classes.root, classes[\"textColor\".concat(capitalize(textColor))], {\n        [classes.disabled]: disabled,\n        [classes.selected]: selected,\n        [classes.labelIcon]: icon && label,\n        [classes.fullWidth]: fullWidth\n      }, className),\n      role: \"tab\",\n      \"aria-selected\": selected,\n      disabled: disabled\n    }, other, {\n      onClick: this.handleChange\n    }), React.createElement(\"span\", {\n      className: classes.wrapper\n    }, icon, label), indicator);\n  }\n\n}\n\nprocess.env.NODE_ENV !== \"production\" ? Tab.propTypes = {\n  /**\n   * This property isn't supported.\n   * Use the `component` property if you need to change the children structure.\n   */\n  children: unsupportedProp,\n\n  /**\n   * Override or extend the styles applied to the component.\n   * See [CSS API](#css-api) below for more details.\n   */\n  classes: PropTypes.object.isRequired,\n\n  /**\n   * @ignore\n   */\n  className: PropTypes.string,\n\n  /**\n   * If `true`, the tab will be disabled.\n   */\n  disabled: PropTypes.bool,\n\n  /**\n   * @ignore\n   */\n  fullWidth: PropTypes.bool,\n\n  /**\n   * The icon element.\n   */\n  icon: PropTypes.node,\n\n  /**\n   * @ignore\n   * For server-side rendering consideration, we let the selected tab\n   * render the indicator.\n   */\n  indicator: PropTypes.node,\n\n  /**\n   * The label element.\n   */\n  label: PropTypes.node,\n\n  /**\n   * @ignore\n   */\n  onChange: PropTypes.func,\n\n  /**\n   * @ignore\n   */\n  onClick: PropTypes.func,\n\n  /**\n   * @ignore\n   */\n  selected: PropTypes.bool,\n\n  /**\n   * @ignore\n   */\n  textColor: PropTypes.oneOf(['secondary', 'primary', 'inherit']),\n\n  /**\n   * You can provide your own value. Otherwise, we fallback to the child position index.\n   */\n  value: PropTypes.any\n} : void 0;\nTab.defaultProps = {\n  disabled: false,\n  textColor: 'inherit'\n};\nexport default withStyles(styles, {\n  name: 'MuiTab'\n})(Tab);","map":null,"metadata":{},"sourceType":"module"}